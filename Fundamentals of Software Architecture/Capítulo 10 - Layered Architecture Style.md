A arquitetura em camadas, também conhecida como arquitetura de múltiplas camadas (n-tiered architecture), é um dos estilos de arquitetura mais comuns. Esse estilo de arquitetura é o padrão de fato para a maioria das aplicações, principalmente por sua simplicidade, familiaridade e baixo custo. 

Também é uma forma muito natural de desenvolver aplicações devido à #lei_de_conway, que afirma que as organizações que projetam sistemas são restritas a produzir designs que são cópias das estruturas de comunicação dessas organizações. Na maioria das organizações, há desenvolvedores de interface de usuário (UI), desenvolvedores backend, desenvolvedores de regras de negócios e especialistas em banco de dados (DBAs). Essas **camadas organizacionais** se encaixam bem nas camadas de um arquitetura tradicional em camadas, tornando-a uma escolha natural para muitas aplicações empresariais. 

O estilo de arquitetura em camadas também se enquadra em vários anti-padrões arquiteturais, incluindo o anti-padrão **arquitetura por implicação** e o anti-padrão **arquitetura acidental**. Se um desenvolvedor ou arquiteto não tem certeza de qual estilo de arquitetura está utilizando, ou se uma equipe de desenvolvimento Ágil "simplesmente começa a codificar", as chances são grandes de que o  estilo de arquitetura em camadas esteja sendo implementado.

## Topology
Os componentes dentro do estilo de arquitetura em camadas são organizados em camadas horizontais lógicas, com cada camada desempenhando um papel específico dentro da aplicação (como lógica de apresentação ou lógica de negócios). Embora não haja restrições específicas em termos do número e tipos de camadas que devem existir, <span style="background:#d4b106">a maioria das arquiteturas em camadas consiste em quatro camadas padrão</span>: 
1. #apresentação 
2. #negócios
3. #Persistência 
4. #Database
Em alguns casos, a camada de negócios e persistência são combinadas em uma única camada de negócios, especialmente quando a lógica de persistência (como SQL ou #HSQL) está embutida dentro dos componentes da camada de negócios. Assim, aplicações menores podem ter apenas três camadas, enquanto aplicações empresariais maiores e mais complexas podem conter cinco ou mais camadas.


![[Capítulo 10 - Layered Architecture Style.png]]

As variações na topologia das camadas.
A **primeira variante** combina as camadas de apresentação, negócios e persistência em uma única unidade de implantação, com a camada de banco de dados geralmente representada como um banco de dados físico externo (ou sistema de arquivos). 
A **segunda variante** separa fisicamente a camada de apresentação em sua própria em sua própria unidade de implantação, enquanto as camadas de negócio e persistência são combinadas em uma segunda unidade de implantação. Novamente, neste tipo de combinação, a camada de banco de dados continua fisicamente separada das demais.

Uma **terceira variante** combina todas as quatro camadas padrão em uma única implantação, incluindo a camada de banco de dados. Essa variante pode ser útil para aplicações menores que utilizam um banco de dados embutido internamente ou um banco de dados em memória. Muitos produtos "on-premises" (instalado localmente) são construídos e entregues aos clientes usando a terceira variante. 

Cada camada possuí um papel e responsabilidades específicas dentro da arquitetura. Por exemplo, a camada de apresentação é responsável por lidar com toda a lógica de comunicação com o usuário e o navegador, enquanto a camada de negócios é encarregada de executar regras de negócios específicas associadas à solicitação.

Cada camada na arquitetura forma uma abstração sobre o trabalho necessário para atender a uma solicitação de negócio específica. Por exemplo, a camada de apresentação não precisa saber ou se preocupar com a forma de obter os dados de um cliente; ela só precisa exibir essas informações na tela em um formato específico. Da mesma forma, a camada de negócios não precisa se preocupar com a formatação dos do cliente para exibição ou mesmo de onde esses valores vêm; ela apenas precisa obter os dados da camada de persistência, aplicar a lógtica de negócio aos dados (como calculara valores ou agregar dados) e passar essas informações para a camada de apresentação.

O conceito de separação de responsabilidades no estilo de arquitetura em camadas facilita a criação de modelos eficazes de papéis e responsabilidades dentro da arquitetura. Componentes em uma camada específica têm escopo limitado, lidando apenas com a lógica pertinente àquela camada. Por exemplo, componentes na camada de apresentação lidam exclusivamente com a lógica de apresentação. Isso permite que os desenvolvedores aproveitem sua expertise técnica específica, concentrando-se nos aspectos técnicos do domínio, como lógica de apresentação ou lógica de persistência. 

O trade-off desse benefício é a falta de agilidade geral, ou seja, a capacidade de responder rapidamente às mudanças. **A arquitetura em camadas é uma arquitetura particionada tecnicamente** (em oposição a uma arquitetura particionada por domínio). Em vez de agrupar componentes por domínio (como "cliente"), eles são agrupados por sua função técnica na arquitetura (como apresentação ou negócios). 

Consequentemente, qualquer domínio de negócio específico acaba sendo **distribuído por todas as camadas da arquitetura**. Por exemplo, o domínio "cliente" pode estar presente na camada de apresentação, na camada de negócios, na camada de regras, na camada de serviços e na camada de banco de dados, tornando difícil implementar mudanças nesse domínio. Por isso, uma abordagem de design orientado a domínio #DDD <span style="background:#d4b106">não funciona tão bem com o estilo de arquitetura em camadas</span>. 

## Layers Of Isolation
Cada camada no estilo de arquitetura em camadas pode ser fechada ou aberta. Uma camada fechada significa que, à medida que uma solicitação é processada de cima para baixo, de camada em camada, ela não pode pular nenhuma camada. Em vez disso, deve passar pela camada imediatamente abaixo para alcançar a próxima. Por exemplo, em uma arquitetura em camadas fechada, uma solicitação que se origina na camada de apresentação deve primeiro passar pela camada de negócios, depois pela camada de persistência e, por fim, chegar à camada de banco de dados. 
![[Capítulo 10 - Layered Architecture Style-1.png]]
Seria muito mais rápido e fácil para a camada de apresentação acessar diretamente o banco de dados para solicitações de recuperação simples, ignorando camadas desnecessárias (uma prática que, no início dos anos 2000, era conhecida como o padrão fast-lane reader). Para que isso aconteça, as camadas de negócios e de persistência precisariam ser abertas, permitindo que solicitações contornassem outras camadas. Qual é a melhor abordagem - camadas abertas ou fechadas? A resposta para essa pergunta está em um conceito-chave, conhecido como *camadas de isolamento*.

O conceito de camadas de isolamento implica que mudanças feitas em uma camada da arquitetura geralmente não impactam ou afetam os componentes de outras camadas, desde que os contratos entre essas camadas permaneçam inalterados. Cada camada é independente das demais, possuindo pouco ou nenhum conhecimento sobre o funcionamento interno de outras camadas da arquitetura. 

Para que as camadas de isolamento sejam mantidas, as camadas envolvidas no fluxo principal da solicitação precisam ser fechadas. Por exemplo, se a camada de apresentação puder acessar diretamente a camada de persistência, alterações feitas na camada de persistência afetariam tanto a camada de negócios quanto a camada de apresentação. **Isso resultaria em uma aplicação fortemente** #acoplada, com interdependências entre camadas e componentes. Tal arquitetura se tornaria muito frágil, além de difícil e custosa para modificar. 

O conceito de *camadas de isolamento* também permite que qualquer camada na arquitetura seja substituída sem impactar as demais (novamente, assumindo contratos bem definidos e o uso do padrão *business delegate*). Por exemplo, é possível aproveitar o conceito de camadas de isolamento dentro do estilo de arquitetura em camadas para substituir uma camada de apresentação baseada em JavaServer Faces JSF por React.js sem afetar outras camadas da aplicação.

## Adding Layers
Embora camadas fechadas facilitem o isolamento de mudanças na arquitetura, promovendo o conceito de *camadas de isolamento*, há situações em que pode ser apropriado que certas camadas sejam abertas.

Por exemplo, suponha que existam objetos compartilhados na camada de negócios que contenham funcionalidades comuns para os componentes de negócios, como classes utilitárias de data e string, classes de auditoria, classes de registro de log, entre outras. Agora suponha que uma decisão arquitetural determina que a camada de apresentação está restrita de utilizar esses objetos compartilhados da camada de negócios. 

Uma solução para restringir o acesso da camada de apresentação aos objetos compartilhados é criar uma nova **camada de serviços contendo todos os objetos de negócios compartilhados**.  Essa adição arquiteturalmente restringe a camada de apresentação de acessar diretamente os objetos compartilhados, já que a camada de negócios é fechada. 

No entanto, essa camada de serviços devem ser marcada como aberta. Caso contrário, a camada de negócios seria obrigada a passar pela camada de serviços para acessar a camada de persistência. Marcar a camada de serviços como abertas, permite que a camada de negócios acessa essa camada (como indicado pela setas sólida.)

A falha em documentar ou comunicar adequadamente quais camadas na arquitetura são abertas e fechadas (e o motivo disso) geralmente resulta em arquiteturas fortemente acopladas e frágeis, que são muito difíceis de testar, manter e implantar.

Logo, a camada de #service é utilizada para abrigar componentes compartilhados ou funcionalidades que podem ser reutilizadas por diversas partes do sistema. 

Sem camadas de serviço, camadas como a de apresentação poderiam acessar diretamente os objetos compartilhados do **Business Layer**, causando dependências indesejadas. A introdução de uma camada de serviço intermediária, permite que essas dependências sejam organizadas de forma mais clara e controlada. 

### Exemplo em um Sistema Real
Imagine um sistema de e-commerce:
- **Camada de Serviços**: Contém funcionalidades como cálculo de frete, envio de notificações e geração de relatórios.
- A **camada de apresentação** não precisa saber como o cálculo de frete é feito, apenas chama um método da camada de serviço.
- A **camada de persistência** não precisa lidar com notificações de e-mail, pois a camada de serviços encapsula isso.
## Other Considerations
A arquitetura em camadas é um bom ponto de partida para a maioria das aplicações quando ainda não se sabe exatamente qual estilo de **arquitetura será utilizado a longo prazo**. Isso é uma prática comum em muitos projetos de microserviços, quando os arquitetos ainda estão determinando se microserviço é a escolha certa de arquitetura, mas o desenvolvimento precisa começar. No entanto, ao usar essa técnica, é importante manter o uso de reutilização ao mínimo e manter as hierarquias de objetos (profundidade da árvore de herança) relativamente rasas para garantir um bom nível de modularidade. Isso ajudará a facilitar a transição para outro estilo de arquitetura no futuro.

Um ponto de atenção na arquitetura em camadas é o anti-padrão " #sinkhole" da arquitetura. Esse anti-padrão ocorre quando as requisições se movem de camada em camada como um simples processamento de passagem, sem lógica de negócios sendo executada em cada camada. Por exemplo, suponhamos que a camada de apresentação responda a uma requisição simples do usuário para recuperar dados básicos do cliente (como o nome e endereço). A camada de apresentação passa a requisição para a camada de negócios, que não faz nada além de passar a requisição para a camada de regras, que por sua vez faz o mesmo, passando a requisição para a camada de persistência. Esta, então, realiza uma chamada SQL simples para a camada do banco de dados para recuperar dados do cliente. Os dados são então retornados ao longo da pilha sem nenhum processamento ou lógica adicional para agregar, calcular, aplicar regras ou transformar os dados. Isso resulta em instanciação desnecessária de objetos e processamento, impactando tanto o consumo de memória quanto o desempenho.

Toda arquitetura em camadas terá, ao menos, alguns cenários que se enquadram no anti-padrão sinkhole da arquitetura. A chave para determinar se o anti-padrão sinkhole está ocorrendo é analisar a **porcentagem de requisições que se enquadram nessa categoria**.  A regra 80-20 é uma boa prática a ser seguida. Por exemplo, é aceitável que se apenas 20% das requisições forem sinkholes, no entanto, se 80% forem sinkholes, isso é um bom indicativo de que a arquitetura em camadas não é o estilo arquitetural correto para o domínio do problema. Uma outra abordagem para resolver o anti-padrão #sinkhole da arquitetura é tornar todas as camadas da arquitetura abertas, sabendo, é claro, que a desvantagem será o aumento da dificuldade em gerenciar mudanças dentro da arquitetura. 

## Why Use this Architecture Style
O estilo de arquitetura em camadas é uma boa escolha para aplicações pequenas e simples ou websites. Também é uma boa escolha arquitetural, especialmente como ponto de partida, para situações com orçamentos e prazos apertados. Devido à sua simplicidade e familiaridade entre desenvolvedores e arquitetos, a arquitetura em camadas é talvez um dos estilos de menor custo, promovendo facilidade de desenvolvimento para aplicações menores. O estilo de arquitetura em camadas também é uma boa escolha quando uma arquiteto ainda está analisando as necessidades e requisitos de negócios e não tem certeza de qual estilo de arquitetura seria o mais adequado.

À medida que as aplicações que utilizam o estilo de arquitetura em camadas crescem, características como manutenibilidade, agilidade, testabilidade e capacidade de implantação são negativamente afetadas. Por essa razão, grandes aplicações e sistemas que utilizam a arquitetura em camadas podem ser mais adequados para outros estilos arquiteturais mais modulares.

Custo e simplicidade são os principais pontos fortes do estilo de arquitetura em camadas. Sendo #monolítica por natureza, as arquiteturas em camadas **não têm as complexidades associadas aos estilos de arquiteturas distribuída**. 

A **capacidade de implantação e a testabilidade** recebem uma avaliação muito baixa para este estilo de arquitetura. A capacidade de implantação é baixa devido à complexidade do processo de implantação (o esforço necessário para implantar), alto risco e falta de implantações frequentes. Uma simples alteração de três linhas em um arquivo de classe no estilo de arquitetura em camadas exige a reimplantação de toda a unidade de implantação, incluindo potenciais alterações no banco de dados, alterações de configuração ou outras modificações no código que podem ser incluídas junto com a alteração original. Além disso, essa simples alteração de três linhas geralmente é agrupada com dezenas de outras alterações, o que aumenta ainda mais o risco de implantação (bem como aumenta a frequência de implantações). 

A baixa avaliação de testabilidade também reflete esse cenário; com uma simples alteração de três linhas, a maioria dos desenvolvedores não gastará horas executando toda a suíte de testes de regressão (mesmo que tal coisa nem exista em primeiro lugar), especialmente junto com dezenas de outras mudanças feitas na aplicação monolítica ao mesmo tempo. A testabilidade recebeu duas estrelas (em vez de uma) devido à possibilidade de simular ou substituir componentes (ou até mesmo uma camada inteira), o que facilita o esforço geral de testes.

A confiabilidade geral recebe uma avaliação média (três estrelas) nesse estilo de arquitetura, principalmente devido à ausência de tráfego de rede, largura de banda e latência encontrados na maioria das arquiteturas distribuídas. A avaliação de três estrelas para confiabilidade no estilo de arquitetura em camadas é atribuída devido à natureza da implantação monolítica, combinada com as baixas avaliações de testabilidade (completude dos testes) e risco de implantação.

A elasticidade e escalabilidade recebem uma avaliação muito baixa (uma estrela) para a arquitetura em camadas, principalmente devido às implantações monolíticas e à falta de modularidade arquitetural. Embora seja possível fazer com que certas funções dentro de um monólito escalem mais do que outras, esse esforço geralmente exige técnicas de design muito complexas, como #multithreading, mensagens internas e outras práticas de processamento paralelo, técnicas para as quais essa arquitetura não é bem adequada. No entanto, devido à arquitetura #monolítica, que inclui a interface de usuário, processamento backend e banco de dados monolíticos, as aplicações só podem escalar até certo ponto com base no único "quantum" do sistema.

A performance é sempre uma característica interessante de avaliar para a arquitetura em camadas. Atribuímos duas estrelas para essa característica, pois o estilo de arquitetura simplesmente não se presta a sistemas de alto desempenho devido à falta de processamento paralelo, camadas fechadas e ao anti-padrão de arquitetura sinkhole. Assim como na escalabilidade, a performance pode ser tratada por meio de cache, multithreading e outras técnicas, mas isso não é uma característica natural desse estilo de arquitetura; arquitetos e desenvolvedores precisam se esforçar muito para que tudo isso funcione adequadamente.

As arquiteturas em camadas não oferecem suporte à tolerância a falhas devido às implantações monolíticas e à falta de modularidade arquitetural. <span style="background:#d4b106">Se uma pequena parte de uma arquitetura em camadas causar uma condição de falta de memória</span>, **toda a unidade da aplicação será impactada e o sistema irá falhar**. Além disso, a disponibilidade geral também é afetada devido ao alto tempo médio de recuperação (MTTR) normalmente experimentado por aplicações monolíticas, com tempos de inicialização variando de 2 minutos para aplicações menores até 15 minutos ou mais para a maioria das aplicações grandes.